# Using `tectonic`

> [!NOTE] `tectonic` spec files have a schema, which can help when writing them.
> Output it with `tectonic schema > workload_schema.json`. In each of your spec
> files, use the `$schema` key in your top level object
> (`{"$schema": "./workload_schema.json"}`) and you will get autocomplete and
> documentation in your code editor.

## Broad Structure

When writing your own workload, the main decisions are

- what operations there will be
- when those operations occur in the workload

Maybe you want some operations to happen at different times, like a preloading
step and a query step.

```txt
I
I
I
...
I
I
P
P
P
P
...
P
P
```

Or maybe you want them interleaved

```txt
I
P
I
P
...
I
P
P
I
```

The next question you need to answer is whether operations will share valid
keys. Valid keys are keys that have been inserted into the DB but not deleted
from it.

Maybe all your operations should use the same set of valid keys.

Or, you want to preload the DB with 10m keys, but only query recent ones, e.g.
you are simulating a workload where only keys in memory are queried.

With these questions answered, you can plan the broad structure of the workload.

- operations that **DO NOT** share valid keys go in different _sections_.
- operations that **DO** share valid keys, but **ARE NOT** interleaved go in
  different _groups_.
- operations that **DO** share valid keys and **ARE** interleaved go in the same
  _group_.

> [!NOTE] JSON files will use the JSONC standard so that comments can be added.
> JSONC support for `tectonic` is planned, but not valid syntax right now.

```jsonc
{
  "$schema": "./workload_schema.json"
  "sections": [
    {
      // a single section
      "groups": [
        {
          // a single group

        }
        {
          // another group

        }
      ]
    },
    {
      // another section
      "groups": []
    }
  ]
}

```

## Operation Details

This section of documentation will focus on how to configure how operations get
generated. This all happens within the same _group_

### Inserts

When generating inserts, you can control the `amount` of inserts that will be
generated, the `key`, and the `val`.

- `amount` is a number, e.g. 100000.
- `key` is a `StringExpr`
- `val` is a `StringExpr`

### Updates/Merges

When generating updates/merges, you can control the `amount`, the `selection`
strategy, and the `val`.

- `amount` is a number, e.g. 100000.
- `selection` is a `NumberExpr`
- `val` is a `StringExpr`

### Point Deletes/Point Queries

When generating point deletes/queries, you can control the `amount` and the
`selection` strategy.

- `amount` is a number, e.g. 100000.
- `selection` is a `NumberExpr`

### Empty Point Deletes/Empty Point Queries

When generating point deletes/queries, you can control the `amount` and the
`key`.

- `amount` is a number, e.g. 100000.
- `key` is a `StringExpr`

### Range Deletes/Range Queries

When generating point deletes/queries, you can control the `amount`, the
`selectivity` (proportion of keys in the range), and the `selection` strategy.

- `amount` is a number, e.g. 100000.
- `selectivity` is a `NumberExpr`
- `selection` is a `NumberExpr`

### `NumberExpr`

`NumberExpr`s describe how to generate a number. They can be

- constants, e.g. 5
- sampled from a statistical distribution, e.g. a number from Uniform(0, 1)

The supported distributions are

- `Uniform`
- `Normal`
- `Beta`
- `Zipf`
- `Exponential`
- `LogNormal`
- `Poisson`
- `Weibull`
- `Pareto`

When using `NumberExpr`s for the `selection` an `selectivity` parameters, they
are limited to [0, 1) (`[0.0, 1.0 - f64::EPSILON]` to be exact). The `Beta`
distribution is most likely what you want to use.

### `StringExpr`

`StringExpr`s describe how to generate a number. They can be

- `Constant`, e.g. "user"
- `Uniform`: uniform random alphanumeric (by default) characters, e.g.
  "hf8e9wa0". Their length is controlled by `len`, which is a `NumberExpr`.
- `Weighted`: a weight list of other `StringExpr`s. When evaluated, a single
  item ti chosen according to the weights. `Segmented`: A list of `StringExpr`s
  join together by string, e,g, "db:table:user1234"
- `HotRange`: A way of biasing certain characters to occur more. This is useful
  when generating keys where certain prefixes occur more than others. The prefix
  length is controlled by `len`. The probability that a "hot" set of character
  is chosen is `probability`. The amount of hot ranges is controlled by
  `amount`. They are generated by sampling a boolean with probability
  `probabiltiy` of being true. If so, it will pick from one of hot ranges
  uniformly, otherwise it will generate `len` random alphanumeric characters.

To generate a key like `usertable:user<ID>`, you would use

```jsonc
{
  "key": {
    // usertable:...
    "segmented": {
      "separator": ":",
      "segments": [
        "usertable",

        // user<ID>
        {
          "segmented": {
            "separator": "",
            "segments": ["user", { "uniform": { "len": 20 } }],
          },
        },
      ],
    },
  },
}
```

To generate 30% of keys going to the "user" table, 30% going to the "post" table, and 40% going to the "userfeed" table, you would use

```json
{
  "key": {
    "weighted": [
      { "weight": 3 "value": "user"... },
      { "weight": 3 "value": "post"... },
      { "weight": 4 "value": "userfeed"... },
    ]
  }
}
```

## Sorted and Mostly Sorted Inserts

To control if inserts appear in a sorted order, add a "sorted" key into a _group_.

```jsonc
{
  "sections": [
    {
      "groups": [
        {
          "sorted": ...
        },
      ],
    },
  ],
}
```

When generating sorted inserts, after sorting them, you can control how many out of place keys there are `k` and the distance that they are out of place `l`.

Both `k` is a number, and `l` is a `NumberExpr`.

If you have 100000 inserts, and you want 5000 out of place where the distance the key is out of place to be sampled from Normal(50, 10), you would use

```jsonc
{
  "sorted": {
    "k": 5000,
    "l": {
      "normal": {
        "mean": 50,
        "std_dev": 10,
      },
    },
  },
}
```
